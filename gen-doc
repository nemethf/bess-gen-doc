#!/usr/bin/env python3

# Copyright (C) 2018 by Felicián Németh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

"""
Generate documentation for bess.


1. Clone or update bess repository,
2. Compile bess with container_build,
3. Extract documentation from protobuf messages,
4. Collect modules and their methods by running bessd in a container,
5. Find method definitions by running gdb,
6. Write a dummy module (mclass.py).
"""

# Uninstall
#
# $ docker image rm gen-bess-doc-mclass
# $ docker image rm nefelinetworks/bess_build
# $ docker image rm pseudomuto/protoc-gen-doc
#

import argparse
import inspect
import json
import logging
import os
import re
import shutil
import subprocess
from pathlib import Path

import logging
logger = logging.getLogger('root')
FORMAT = "%(filename)s:%(lineno)s %(funcName)s %(message)s"
logging.basicConfig(format=FORMAT)
logger.setLevel(logging.ERROR)

wdir = Path(__file__).parent
bess_dir = wdir / 'bess'
db = None

class FileWithLineNumber(object):
    def __init__(self, f):
        self.f = f
        self.line = 0

    def write(self, str):
        self.line += str.count("\n")
        self.f.write(str)


def check_call(cmd, **kw):
    "Like subprocess.check_call, but args can be Path objects as well."
    if type(cmd) == list:
        cmd = [ str(item) for item in cmd ]
    for k, v in kw.items():
        if isinstance(v, Path):
            kw[k] = str(v)
    return subprocess.check_call(cmd, **kw)

def update_bess():
    if not bess_dir.exists():
        cmd = ['git', 'clone', '-q', 'https://github.com/NetSys/bess.git']
        check_call(cmd, cwd=wdir)
    else:
        cmd = ['git', 'pull', '-q', 'origin', 'master']
        check_call(cmd, cwd=bess_dir)

def compile_bess():
    build_cmd = 'container_build.py'
    safe_version = wdir / 'safe_container_build.py'
    if not safe_version.exists():
        shutil.copyfile(str(bess_dir / build_cmd), str(safe_version))
    else:
        cmd = ['diff', '-q',
               str(safe_version.resolve()),
               str((bess_dir / build_cmd).resolve())]
        try:
            subprocess.check_output(cmd, cwd=str(wdir))
        except subprocess.CalledProcessError as e:
            print("%s" % e)
            print("There's a new version of %s" % build_cmd)
            print("If you think it's safe to run, run this command:")
            print(" cp '%s' '%s'" % (bess_dir / build_cmd, safe_version))
            exit(1)
    cmd = [build_cmd, 'bess']
    env = os.environ.copy()
    env['DEBUG'] = '1'
    env['PATH'] += ':.'
    check_call(cmd, cwd=bess_dir, env=env)

def run_protoc_gen_doc():
    image = 'pseudomuto/protoc-gen-doc'
    outdir = wdir / 'protoc-gen-doc'
    outfile = 'bess-protobuf.json'
    outdir.mkdir(exist_ok=True)
    cmd = ['docker', 'run', '--rm',
           '-v', '%s:/out' % outdir.resolve(),
           '-v', '%s:/protos:ro' % (bess_dir / 'protobuf').resolve(),
           image,
           '--doc_opt=json,%s' % outfile]
    check_call(cmd, cwd=wdir)

def gen_mclass_info():
    image = 'gen-bess-doc-mclass'
    outdir = wdir / 'mclass'
    src_dir = wdir / 'save-mclass-info'
    outdir.mkdir(exist_ok=True)

    # Build the image if it doesn't exist locally
    #
    # (build in an almost empty dir, otherwise the "build context" is
    # huge")
    cmd = ['docker', 'images', '-q', image]
    if not subprocess.check_output(cmd):
        cmd = ['docker', 'build', '-t', image, '.']
        subprocess.run(cmd, cwd=str(src_dir))

    # Run the image
    cmd = ['docker', 'run', '--rm',
           '-v', '%s:/out' % outdir.resolve(),
           '-v', '%s:/bess:ro' % bess_dir.resolve(),
           '-v', '%s:/bess-gen-doc:ro' % src_dir.resolve(),
           image]
    check_call(cmd, cwd=wdir)

def to_camel_case(snake_string):
    return snake_string.title().replace("_", "")

gdb_proc = None
def get_gdb_info(member_func):
    # Compile bess as: DEBUG=1 ./container_build.py
    #
    # (gdb) info line DRR::SetQuantumSize
    global gdb_proc
    if gdb_proc is None:
        gdb_proc = subprocess.Popen(['gdb', str(bess_dir / 'bin' / 'bessd')],
                                    stdin=subprocess.PIPE,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT)
        while True:
            line = gdb_proc.stdout.readline().decode('utf-8')
            # print(line.rstrip())
            if line.startswith("Reading symbols from "):
                break
    gdb_proc.stdin.write(('info line %s\n' % member_func).encode('utf-8'))
    gdb_proc.stdin.flush()
    response = ''
    while not response.endswith('.'):
        line = gdb_proc.stdout.readline().decode('utf-8').strip()
        response += line
    if response.endswith('not defined.'):
        return None
    m = re.match(r'.gdb. Line (\d+) of "([^"]+)"', response)
    if m:
        return {'file': 'core/' + m.group(2), 'line': int(m.group(1))}

    raise ValueError('Unknown gdb response: %s' % response)

def find_def(class_name, func_name, msg_name):
    loc = None
    m = re.search('(\w+)Command(\w+)(Arg)', msg_name)
    if m:
        loc = get_gdb_info("%s::%s" % (m.group(1), m.group(2)))
    if m and not loc:
        loc = get_gdb_info("%s::Command%s" % (m.group(1), m.group(2)))
    if not loc:
        loc = get_gdb_info("%s::%s" % (class_name, to_camel_case(func_name)))
    if not loc:
        funcName = to_camel_case(func_name)
        loc = get_gdb_info("%s::Command%s" % (class_name, funcName))
    return loc

def find_usage_exampe(class_name):
    logger.debug('class_name=%s', class_name)
    # grep -Horn -m 1 '\bSink(' bessctl/conf/samples
    if not re.match(r'\w+', class_name):
        return []
    location = []
    cmd = ['grep', '-Hornm', '1', '\\b%s(' % class_name, 'bessctl/conf/samples']
    try:
        output = subprocess.check_output(cmd, cwd=str(bess_dir))
    except subprocess.CalledProcessError as e:
        if e.returncode == 1:
            # no matches found
            return []
        raise e
    for line in output.decode('utf-8').strip().split('\n'):
        parts = line.split(":")
        location.append({'file': parts[0], 'line': int(parts[1])})
    return sorted(location, key=lambda l: (l['file'], l['line']))

def set_protobuf_lineno(messages):
    "Modify each msg by adding the line number where msg was defined."
    # Ideally, we should modify pseudomuto/protoc-gen-doc instead of
    # this hack.
    loc = {}
    with (bess_dir / 'protobuf' / 'module_msg.proto').open() as f:
        for lineno, line in enumerate(f, start=1):
            m = re.match(r'^\s*message\s+(\S+)', line)
            if not m:
                continue
            loc[m.group(1)] = lineno
    for name, m in messages.items():
        logger.debug('name: %s', name)
        if name in loc:
            m['line'] = loc[name]

def write_combined_db():
    with (wdir / 'protoc-gen-doc' / 'bess-protobuf.json').open() as f:
        protobuf = json.load(f)
    with (wdir / 'mclass' / 'bessd-mclass.json').open() as f:
        minfo = json.load(f)

    msg = {}
    for f in protobuf['files']:
        if f['name'] != 'module_msg.proto':
            continue
        for m in f['messages']:
            msg[m['name']] = m
        set_protobuf_lineno(msg)
    for mclass in minfo:
        class_name = mclass['name']
        cmd_arg = '%s%s' % (class_name, 'Arg')
        cmd_name = '__init__'
        class_doc = msg.get(cmd_arg)
        mclass['definition'] = find_def(class_name, cmd_name, cmd_arg)
        mclass['examples'] = find_usage_exampe(class_name)
        mclass['arg'] = cmd_arg
        for cmd in mclass['cmds']:
            m = msg.get(re.sub(r'Arg$', 'Response', cmd['arg']))
            if m:
                cmd['return'] = m
            cmd['definition'] = find_def(class_name, cmd['cmd'], cmd['arg'])

    global db
    db = {
        'msg': msg,
        'mclass': minfo,
    }
    (wdir / 'out').mkdir(exist_ok=True)
    write_db()
    return db

def indent(string, columns):
    ret = string.split('\n')
    ret = [' ' * columns + line if len(line)>0 else line for line in ret]
    ret = '\n'.join(ret)
    return ret

def conv_loc(location):
    filename = location['file']
    if not Path(filename).is_absolute():
        filename = '$BESS/' + filename
    return '%s:%s' % (filename, location['line'])

def write_def(f, msg, class_name, cmd):
    fields = []
    args = "self"
    m = msg.get(cmd['arg'])
    doc = []
    if m:
        doc.append(m['description'])
        fields += m['fields']
    args_doc = []
    for field in fields:
        args += ', %s=None' % field['name']
        if field.get('description'):
            args_doc.append(":param %s: %s" %
                            (field['name'], field['description']))

    doc.append('\n'.join(args_doc))
    m = msg.get(re.sub(r'Arg$', 'Response', cmd['arg']))
    if m:
        doc.append(":return: %s" % m['description'])
        # TODO: print "fileds" here as well
    if ARGS.links and cmd.get('definition'):
        doc.append('Definition:\n  %s' % conv_loc(cmd['definition']))
    doc = [d for d in doc if d]
    if doc:
        doc = '\n"""\n%s\n"""' % '\n\n'.join(doc)
        doc = indent(doc, 4)
    else:
        doc = ''
    cmd['line'] = f.line + 1
    f.write('  def %s(%s):%s\n    pass\n\n' % (
        cmd['cmd'], args, doc))

def load_db():
    global db
    if db:
        return db

    with (wdir / 'out' / 'db.json').open() as f:
        db = json.load(f)
    return db

def write_db():
    logger.debug('.')
    db_file = wdir / 'out' / 'db.json'
    with db_file.open('w') as f:
        json.dump(db, f, indent=2, sort_keys=True, separators=(',', ': '))

def write_dummy_module():
    db = load_db()

    msg = db['msg']
    with (wdir / 'mclass.py').open('w') as fobj:
        f = FileWithLineNumber(fobj)
        cfile = 'bess/protobuf/module_msg.proto'
        f.write("# This file is auto-genereated by bess-gen-doc.\n")
        f.write("# See https://github.com/nemethf/bess-gen-doc\n")
        f.write("#\n# It is based on %s, which "
                "has the following copyright.\n\n" % cfile)
        with (wdir / cfile).open() as cf:
            for line in cf:
                if not line.startswith('//'):
                    break
                f.write(line.replace('//', '#'))
        f.write("\n\n")
        f.write("from pybess.module import Module\n")
        f.write("from pybess.bess import BESS\n\n")
        f.write("bess = BESS()\n\n")
        for info in db['mclass']:
            class_name = info['name']
            cmd_arg = '%s%s' % (class_name, 'Arg')
            doc = [info['help']]
            class_doc = msg.get(cmd_arg)
            if class_doc:
                doc.append(class_doc['description'])
            if ARGS.links and info['definition']:
                doc.append('Definition:\n  %s' % conv_loc(info['definition']))
            if ARGS.links and info['examples']:
               ex = [conv_loc(loc) for loc in info['examples']]
               doc.append('Example usage:\n  %s' % '\n  '.join(ex))

            f.write('class %s(Module):\n' % class_name)
            info['line'] = f.line
            doc = [d for d in doc if d]
            if doc:
                doc = indent('\n\n'.join(doc), 2)
                f.write('  """\n%s\n  """\n\n' % doc)
            if class_doc:
                cmd = {
                    'arg': cmd_arg,
                    'cmd': '__init__',
                    'definition': info['definition'],
                }
                write_def(f, msg, class_name, cmd)

            for cmd in info['cmds']:
                write_def(f, msg, class_name, cmd)
            f.write('\n')
    write_db()

def main(args):
    steps = [
        update_bess,
        compile_bess,
        run_protoc_gen_doc,
        gen_mclass_info,
        write_combined_db,
        write_dummy_module,
    ]
    for i, step in enumerate(steps, start=1):
        if i < args.start:
            continue
        logger.debug('Starting step %s: %s', i, step.__name__)
        step()


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.description = inspect.getdoc(inspect.getmodule(main))
    parser.add_argument('--start', '-s', type=int, default=1, metavar='S',
                        help="Start at step S (while skipping previous steps).")
    parser.add_argument('--links', '-l', action='store_true',
                        help="Add 'links' to docstrings.")
    parser.add_argument('--verbose', '-v', action='store_true')
    ARGS = parser.parse_args()
    if ARGS.verbose:
        logger.setLevel(logging.DEBUG)
    main(ARGS)
